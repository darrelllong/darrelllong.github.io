<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>404 Not Found</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: url('https://darrelllong.github.io/not-found.jpg') no-repeat center center fixed;
      background-size: cover;
      font-family: sans-serif;
    }
    #gameCanvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.7);
    }
    .message {
      position: absolute;
      top: 20px;
      width: 100%;
      text-align: center;
      font-size: 24px;
      color: #fff;
      text-shadow: 0 0 5px rgba(0,0,0,0.7);
      z-index: 2;
      pointer-events: none;
    }
  </style>
</head>
<body>
  <div class="message">404 Not Found</div>
  <canvas id="gameCanvas"></canvas>
  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    
    // Game states
    const GAME_STATES = {
      START: 'start',
      PLAYING: 'playing',
      GAME_OVER: 'game_over'
    };
    
    let gameState = GAME_STATES.START;
    let score = 0;
    let lives = 3;
    let level = 1;
    
    // Game objects
    let player = {
      x: 0,
      y: 0,
      width: 40,
      height: 20,
      speed: 5
    };
    
    let invaders = [];
    let playerBullets = [];
    let enemyBullets = [];
    let particles = [];
    let ufo = null;
    let animationFrame = 0;
    
    // Game settings
    const INVADER_ROWS = 5;
    const INVADER_COLS = 11;
    const INVADER_WIDTH = 32;
    const INVADER_HEIGHT = 24;
    const INVADER_SPACING = 8;
    const BULLET_SPEED = 6;
    const MAX_PLAYER_BULLETS = 3;
    const UFO_SPEED = 2;
    
    // Sprite patterns (using text for retro look)
    const sprites = {
      player: ['▲▲▲▲▲', '█████', '█████'],
      invader1: ['  ▄▄  ', ' ████ ', '██████', '██▄▄██', '▄▄  ▄▄'],
      invader2: [' ▄██▄ ', '██████', '███▄██', '██████', '▄▄██▄▄'],
      invader3: ['▄████▄', '██████', '██▄▄██', ' ████ ', ' ▄██▄ '],
      ufo: ['▄▄████▄▄', '████████', '▄██████▄', ' ▄▄▄▄▄▄ ']
    };
    
    // Input handling
    const keys = {};
    let canShoot = true;
    let shootCooldown = 0;
    
    window.addEventListener('keydown', (e) => {
      keys[e.code] = true;
      
      if (e.code === 'Enter') {
        if (gameState === GAME_STATES.START) {
          startGame();
        } else if (gameState === GAME_STATES.GAME_OVER) {
          resetGame();
        }
      }
      
      if (e.code === 'Space' && gameState === GAME_STATES.PLAYING) {
        shootPlayerBullet();
        e.preventDefault();
      }
    });
    
    window.addEventListener('keyup', (e) => {
      keys[e.code] = false;
    });
    
    function resize() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      
      // Position player at bottom center
      player.x = canvas.width / 2 - player.width / 2;
      player.y = canvas.height - player.height - 30;
      
      // Initialize invaders if game is playing
      if (gameState === GAME_STATES.PLAYING && invaders.length === 0) {
        initInvaders();
      }
    }
    
    function startGame() {
      gameState = GAME_STATES.PLAYING;
      score = 0;
      lives = 3;
      level = 1;
      playerBullets = [];
      enemyBullets = [];
      particles = [];
      initInvaders();
    }
    
    function resetGame() {
      gameState = GAME_STATES.START;
      invaders = [];
      playerBullets = [];
      enemyBullets = [];
      particles = [];
    }
    
    function initInvaders() {
      invaders = [];
      const startX = (canvas.width - (INVADER_COLS * (INVADER_WIDTH + INVADER_SPACING) - INVADER_SPACING)) / 2;
      const startY = 100;
      
      for (let row = 0; row < INVADER_ROWS; row++) {
        for (let col = 0; col < INVADER_COLS; col++) {
          let invaderType;
          let points;
          if (row === 0) { invaderType = 3; points = 30; }
          else if (row <= 2) { invaderType = 2; points = 20; }
          else { invaderType = 1; points = 10; }
          
          invaders.push({
            x: startX + col * (INVADER_WIDTH + INVADER_SPACING),
            y: startY + row * (INVADER_HEIGHT + INVADER_SPACING),
            width: INVADER_WIDTH,
            height: INVADER_HEIGHT,
            type: invaderType,
            points: points,
            alive: true,
            animFrame: 0
          });
        }
      }
    }
    
    function spawnUFO() {
      if (!ufo && Math.random() < 0.0008) { // Random UFO spawn
        ufo = {
          x: -100,
          y: 50,
          width: 64,
          height: 32,
          speed: UFO_SPEED,
          points: 100 + Math.floor(Math.random() * 200), // 100-300 points
          alive: true
        };
      }
    }
    
    function shootPlayerBullet() {
      if (playerBullets.length < MAX_PLAYER_BULLETS && canShoot) {
        playerBullets.push({
          x: player.x + player.width / 2 - 2,
          y: player.y,
          width: 4,
          height: 10,
          speed: -BULLET_SPEED
        });
        canShoot = false;
        shootCooldown = 10;
      }
    }
    
    function updatePlayer() {
      // Movement
      if (keys['ArrowLeft'] && player.x > 0) {
        player.x -= player.speed;
      }
      if (keys['ArrowRight'] && player.x < canvas.width - player.width) {
        player.x += player.speed;
      }
      
      // Shooting cooldown
      if (shootCooldown > 0) {
        shootCooldown--;
        if (shootCooldown === 0) {
          canShoot = true;
        }
      }
    }
    
    function updateBullets() {
      // Update player bullets
      for (let i = playerBullets.length - 1; i >= 0; i--) {
        const bullet = playerBullets[i];
        bullet.y += bullet.speed;
        
        // Remove bullets that go off screen
        if (bullet.y < 0) {
          playerBullets.splice(i, 1);
        }
      }
      
      // Update enemy bullets
      for (let i = enemyBullets.length - 1; i >= 0; i--) {
        const bullet = enemyBullets[i];
        bullet.y += bullet.speed;
        
        // Remove bullets that go off screen
        if (bullet.y > canvas.height) {
          enemyBullets.splice(i, 1);
        }
      }
    }
    
    function updateInvaders() {
      if (invaders.length === 0) return;
      
      let shouldMoveDown = false;
      const aliveInvaders = invaders.filter(inv => inv.alive);
      const speed = 0.5 + (level - 1) * 0.3 + (55 - aliveInvaders.length) * 0.05; // Speed increases as invaders die
      
      // Check if any invader hits the edge
      for (const invader of invaders) {
        if (!invader.alive) continue;
        if ((invader.x <= 10 && invader.direction === -1) || 
            (invader.x >= canvas.width - invader.width - 10 && invader.direction === 1)) {
          shouldMoveDown = true;
          break;
        }
      }
      
      // Move invaders
      for (const invader of invaders) {
        if (!invader.alive) continue;
        
        if (shouldMoveDown) {
          invader.y += 16;
          invader.direction = invader.direction || 1;
          invader.direction *= -1;
        } else {
          invader.direction = invader.direction || 1;
          invader.x += speed * invader.direction;
        }
        
        // Update animation frame
        invader.animFrame = Math.floor(animationFrame / 30) % 2;
      }
      
      // More aggressive enemy shooting - multiple bullets
      const shootChance = 0.004 + level * 0.002 + (55 - aliveInvaders.length) * 0.0001;
      if (Math.random() < shootChance && aliveInvaders.length > 0) {
        // Find bottom-most invaders in each column
        const bottomInvaders = {};
        for (const invader of aliveInvaders) {
          const col = Math.floor((invader.x - aliveInvaders[0].x) / (INVADER_WIDTH + INVADER_SPACING));
          if (!bottomInvaders[col] || invader.y > bottomInvaders[col].y) {
            bottomInvaders[col] = invader;
          }
        }
        
        const shooters = Object.values(bottomInvaders);
        const shooter = shooters[Math.floor(Math.random() * shooters.length)];
        
        enemyBullets.push({
          x: shooter.x + shooter.width / 2 - 2,
          y: shooter.y + shooter.height,
          width: 3,
          height: 8,
          speed: BULLET_SPEED + Math.random() * 2
        });
      }
    }
    
    function updateUFO() {
      if (ufo) {
        ufo.x += ufo.speed;
        if (ufo.x > canvas.width + 100) {
          ufo = null;
        }
      }
    }
    
    function checkCollisions() {
      // Player bullets vs invaders
      for (let i = playerBullets.length - 1; i >= 0; i--) {
        const bullet = playerBullets[i];
        
        for (const invader of invaders) {
          if (!invader.alive) continue;
          
          if (bullet.x < invader.x + invader.width &&
              bullet.x + bullet.width > invader.x &&
              bullet.y < invader.y + invader.height &&
              bullet.y + bullet.height > invader.y) {
            
            // Hit invader
            invader.alive = false;
            playerBullets.splice(i, 1);
            score += invader.points;
            
            // Create explosion particles
            createExplosion(invader.x + invader.width / 2, invader.y + invader.height / 2);
            break;
          }
        }
        
        // Player bullets vs UFO
        if (ufo && ufo.alive) {
          if (bullet.x < ufo.x + ufo.width &&
              bullet.x + bullet.width > ufo.x &&
              bullet.y < ufo.y + ufo.height &&
              bullet.y + bullet.height > ufo.y) {
            
            // Hit UFO
            ufo.alive = false;
            playerBullets.splice(i, 1);
            score += ufo.points;
            
            // Create special explosion for UFO
            createExplosion(ufo.x + ufo.width / 2, ufo.y + ufo.height / 2, true);
            
            // Show points briefly
            setTimeout(() => { ufo = null; }, 1000);
            break;
          }
        }
      }
      
      // Enemy bullets vs player
      for (let i = enemyBullets.length - 1; i >= 0; i--) {
        const bullet = enemyBullets[i];
        
        if (bullet.x < player.x + player.width &&
            bullet.x + bullet.width > player.x &&
            bullet.y < player.y + player.height &&
            bullet.y + bullet.height > player.y) {
          
          // Player hit
          enemyBullets.splice(i, 1);
          lives--;
          createExplosion(player.x + player.width / 2, player.y + player.height / 2);
          
          if (lives <= 0) {
            gameState = GAME_STATES.GAME_OVER;
          }
          break;
        }
      }
      
      // Check if all invaders destroyed
      const aliveInvaders = invaders.filter(inv => inv.alive);
      if (aliveInvaders.length === 0 && gameState === GAME_STATES.PLAYING) {
        level++;
        initInvaders();
      }
      
      // Check if invaders reached player
      for (const invader of invaders) {
        if (invader.alive && invader.y + invader.height >= player.y) {
          gameState = GAME_STATES.GAME_OVER;
          break;
        }
      }
    }
    
    function createExplosion(x, y, isUFO = false) {
      const particleCount = isUFO ? 16 : 8;
      const speed = isUFO ? 8 : 6;
      const life = isUFO ? 40 : 30;
      
      for (let i = 0; i < particleCount; i++) {
        particles.push({
          x: x,
          y: y,
          vx: (Math.random() - 0.5) * speed,
          vy: (Math.random() - 0.5) * speed,
          life: life,
          maxLife: life,
          isUFO: isUFO
        });
      }
    }
    
    function updateParticles() {
      for (let i = particles.length - 1; i >= 0; i--) {
        const particle = particles[i];
        particle.x += particle.vx;
        particle.y += particle.vy;
        particle.life--;
        
        if (particle.life <= 0) {
          particles.splice(i, 1);
        }
      }
    }
    
    function drawSprite(sprite, x, y, color = '#ffffff', scale = 1) {
      ctx.fillStyle = color;
      ctx.font = `${12 * scale}px monospace`;
      ctx.textAlign = 'left';
      ctx.textBaseline = 'top';
      
      for (let i = 0; i < sprite.length; i++) {
        ctx.fillText(sprite[i], x, y + i * 12 * scale);
      }
    }
    
    function drawPlayer() {
      drawSprite(sprites.player, player.x, player.y, '#00ff00', 1);
    }
    
    function drawInvaders() {
      for (const invader of invaders) {
        if (!invader.alive) continue;
        
        let spriteKey = `invader${invader.type}`;
        let color;
        
        // Different colors for different types
        if (invader.type === 3) color = '#ff0000';
        else if (invader.type === 2) color = '#ffaa00';
        else color = '#00ffff';
        
        drawSprite(sprites[spriteKey], invader.x, invader.y, color, 0.8);
      }
    }
    
    function drawUFO() {
      if (ufo && ufo.alive) {
        drawSprite(sprites.ufo, ufo.x, ufo.y, '#ff00ff', 1);
      } else if (ufo && !ufo.alive) {
        // Show points for destroyed UFO
        ctx.fillStyle = '#ffff00';
        ctx.font = '16px monospace';
        ctx.textAlign = 'center';
        ctx.fillText(`${ufo.points}`, ufo.x + ufo.width / 2, ufo.y + ufo.height / 2);
      }
    }
    
    function drawBullets() {
      // Player bullets
      ctx.fillStyle = '#ffffff';
      for (const bullet of playerBullets) {
        ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
      }
      
      // Enemy bullets
      ctx.fillStyle = '#ff0000';
      for (const bullet of enemyBullets) {
        ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
      }
    }
    
    function drawParticles() {
      for (const particle of particles) {
        const alpha = particle.life / particle.maxLife;
        if (particle.isUFO) {
          ctx.fillStyle = `rgba(255, 0, 255, ${alpha})`;
        } else {
          ctx.fillStyle = `rgba(255, 255, 0, ${alpha})`;
        }
        ctx.fillRect(particle.x - 2, particle.y - 2, 4, 4);
      }
    }
    
    function drawUI() {
      ctx.fillStyle = '#ffffff';
      ctx.font = '20px sans-serif';
      ctx.textAlign = 'left';
      
      // Score
      ctx.fillText(`Score: ${score}`, 20, canvas.height - 60);
      
      // Lives
      ctx.fillText(`Lives: ${lives}`, 20, canvas.height - 30);
      
      // Level
      ctx.fillText(`Level: ${level}`, canvas.width - 120, canvas.height - 30);
      
      if (gameState === GAME_STATES.START) {
        ctx.textAlign = 'center';
        ctx.font = '32px sans-serif';
        ctx.fillText('SPACE INVADERS', canvas.width / 2, canvas.height / 2 - 100);
        ctx.font = '20px sans-serif';
        ctx.fillText('Press ENTER to Start', canvas.width / 2, canvas.height / 2 - 50);
        ctx.fillText('Arrow Keys to Move, SPACE to Shoot', canvas.width / 2, canvas.height / 2 - 20);
      } else if (gameState === GAME_STATES.GAME_OVER) {
        ctx.textAlign = 'center';
        ctx.font = '32px sans-serif';
        ctx.fillText('GAME OVER', canvas.width / 2, canvas.height / 2 - 50);
        ctx.font = '20px sans-serif';
        ctx.fillText(`Final Score: ${score}`, canvas.width / 2, canvas.height / 2 - 10);
        ctx.fillText('Press ENTER to Restart', canvas.width / 2, canvas.height / 2 + 20);
      }
    }
    
    function update() {
      animationFrame++;
      
      if (gameState === GAME_STATES.PLAYING) {
        updatePlayer();
        updateBullets();
        updateInvaders();
        updateUFO();
        spawnUFO();
        checkCollisions();
        updateParticles();
      }
    }
    
    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      if (gameState === GAME_STATES.PLAYING) {
        drawPlayer();
        drawInvaders();
        drawUFO();
        drawBullets();
        drawParticles();
      }
      
      drawUI();
    }
    
    function gameLoop() {
      update();
      draw();
      requestAnimationFrame(gameLoop);
    }
    
    window.addEventListener('resize', resize);
    resize();
    gameLoop();
  </script>
</body>
</html>
